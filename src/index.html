<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Block Breakers</title>
  	<script type="text/javascript" src="js/phaser.min.js"></script>
  	<script src="js/blockBreakers.js"></script>
    <style>
      body {
        background: #202028;
        color: #fff;
        font-family: sans-serif;
        font-size: 2em;
        text-align: center;
      }
      canvas {
        padding: 0;
        margin: auto;
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }
    </style>
</head>
<body>

<div id="game_canvas"></div>
<script type="text/javascript">

var game = new Phaser.Game(480, 800, Phaser.CANVAS, 'game_canvas', { preload: preload, create: create, update: update, render: render });

const colors = [
    null,
    '#FF0D72',
    '#0DC2FF',
    '#0DFF72',
    '#F538FF',
    '#FF8E0D',
    '#FFE138',
    '#3877FF',
];

var block;

var arena = {
  w: 12,
  h: 20,
  matrix: [], 

  createMatrix: function() {
    for(let i = 0; i < this.h; i++){
      this.matrix.push(new Array(this.w).fill(0));
    }
  },

  merge: function (arena, player){
    for(let y = 0; y < player.matrix.length; y++){
      for(let x = 0; x < player.matrix[1].length; x++){
        if (player.matrix[y][x] !== 0) {
          arena.matrix[y + player.pos.y] [x + player.pos.x] = player.matrix[y][x];
        }
      }
    }
  },

  arenaSweep: function (){

    let rowCount = 1;

    for(let j = 1; j < arena.matrix.length; j++){
      if(!arena.matrix[j].includes(0)){
        arena.clearRow(j);
      }
    }

    player.score += rowCount * 10;
    rowCount *= 2;
  },

  clearRow: function (actual){
    do {
      this.matrix[actual] = this.matrix[actual - 1].slice();
      actual--;
    } while(!arena.emptyRow(actual - 1) && actual > 0);

    this.matrix[actual].fill(0);
  },

  emptyRow: function(fila){
    let col = 0;
    do {
      if (this.matrix[fila][col] !== 0){
        return false;
      }
      col++;
    } while (col < this.w);

    return true;
  }

}

var player = {
      pos: {x: 0, y: 0},
      score: 0,
      matrix: null,

      playerDrop: function (){
        this.pos.y++;
        if (logic.collide(arena, player)) {
            this.pos.y--;
            arena.merge(arena, player);
            player.playerReset();
            arena.arenaSweep();
            //updateScore();
        }

        logic.dropCounter = 0;
      },

      playerMove: function (dir){
        player.pos.x += dir;
        if(logic.collide(arena, player)) {
          player.pos.x -= dir;
        }
      },

      createPiece: function (type){
          if (type === 'I') {
              return [
                  [0, 1, 0, 0],
                  [0, 1, 0, 0],
                  [0, 1, 0, 0],
                  [0, 1, 0, 0],
              ];
          } else if (type === 'L') {
              return [
                  [0, 2, 0],
                  [0, 2, 0],
                  [0, 2, 2],
              ];
          } else if (type === 'J') {
              return [
                  [0, 3, 0],
                  [0, 3, 0],
                  [3, 3, 0],
              ];
          } else if (type === 'O') {
              return [
                  [4, 4],
                  [4, 4],
              ];
          } else if (type === 'Z') {
              return [
                  [5, 5, 0],
                  [0, 5, 5],
                  [0, 0, 0],
              ];
          } else if (type === 'S') {
              return [
                  [0, 6, 6],
                  [6, 6, 0],
                  [0, 0, 0],
              ];
          } else if (type === 'T') {
              return [
                  [0, 7, 0],
                  [7, 7, 7],
                  [0, 0, 0],
              ];
          }
      },

      playerReset: function (){
        const pieces = 'TJLOSZI';
        player.matrix = player.createPiece(pieces[pieces.length * Math.random() | 0]);
        player.pos.y = 0;
        player.pos.x = (arena.matrix[0].length / 2 | 0) -
                       (player.matrix[0].length / 2 | 0);
        if (logic.collide(arena, player)) {
            for(let i = 0; i < arena.h; i++){
              arena.matrix[i].fill(0);
            }
            player.score = 0;
            //updateScore();
        }
      },

      rotate: function (matrix, dir){
        for(let y = 0; y < matrix.length; y++) {
          for(let x = 0; x < y; x++) {
            [
              matrix[x][y],
              matrix[y][x],
            ] = [
              matrix[y][x],
              matrix[x][y],
            ];
          }
        }

        if (dir > 0) {
          matrix.forEach(row => row.reverse());
        } else {
          matrix.reverse();
        }
      },

      playerRotate: function (dir){
          const pos = player.pos.x;
          let offset = 1;
          player.rotate(player.matrix, dir);
          while (logic.collide(arena, player)) {
              player.pos.x += offset;
              offset = -(offset + (offset > 0 ? 1 : -1));
              if (offset > player.matrix[0].length) {
                  rotate(player.matrix, -dir);
                  player.pos.x = pos;
                  return;
              }
          }
      }
}

var renderer = {
  drawMatrix: function(matrix, offset) {
    for(let y = 0; y < matrix.length; y++){
      for(let x = 0; x < matrix[1].length; x++){

        block.x = (x + offset.x)*40;
        block.y = (y + offset.y)*40;

        if(matrix[y][x] !== 0) {
          game.debug.geom(block, colors[matrix[y][x]]);
        }
      } 
    }
  },

  draw: function(){
    renderer.drawMatrix(arena.matrix, {x: 0, y: 0});
    renderer.drawMatrix(player.matrix, player.pos);
  }
}

var logic = { //La lógica del juego, no el segundo mejor MC del mundo después de Kendrick
  
  dropCounter: 0,
  dropInterval: 1000,

  //Devuelve "true" si hay colisión entre piezas del tablero "arena" y nuestra pieza
  collide: function (arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for (let y = 0; y < m.length; y++) {
      for (let x = 0; x < m[y].length; x++) {
        if (m[y][x] !== 0 &&
           (arena.matrix[y + o.y] &&
            arena.matrix[y + o.y][x + o.x]) !== 0) {
            return true;
        }
      }
    }
    return false;
  },

  update: function(time = 0){
    this.dropCounter += game.time.elapsed;
    if (this.dropCounter > this.dropInterval){
      player.playerDrop();
    }
  },

  /*updateScore: function(){
    document.getElementById('score').innerText = player.score;
  }*/
}

var sounds = {

  musica: null,

  update: function(){
    if(!this.musica.isPlaying){
      this.musica.play();
    }
  }
}

document.addEventListener('keydown', event => {
  if (event.keyCode === 37){
    player.playerMove(-1);
  } else if (event.keyCode === 39) {
    player.playerMove(1);
  } else if (event.keyCode === 40) {
    player.playerDrop();
  } else if (event.keyCode === 81) {
    player.playerRotate(-1);
  } else if (event.keyCode === 87) {
    player.playerRotate(1);
  }
});

function preload() {
  game.load.audio('ErMusicote', ['assets/sounds/COMLoop.ogg']);
}

function create() {  
    block = new Phaser.Rectangle(0,0, 40, 40);
    arena.createMatrix();
    player.playerReset();
    sounds.musica = game.add.audio('ErMusicote');
    //sounds.musica.play('', 0, 1, true);
}

function update() {
  logic.update();
  sounds.update();
}

function render () {

  renderer.draw();
  /*DEBBUGING
  var x = 32;
  var y = 0;
  var yi = 32;
  game.debug.text('Arena', x, y += yi);
  game.debug.text('Alto: ' + arena.matrix.length, x, y += yi);
  game.debug.text('Ancho: ' + arena.matrix[0].length, x, y += yi);*/
}



</script>

</body>
</html>
